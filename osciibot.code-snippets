{
    "WHILE OSCIIBOT": {
        "prefix": "while",
        "scope": "eel2",
        "body": "while(${1:expression})$0",
        "description": "[OSCIIBOT]\n\nExecutes expression until expression evaluates to zero, or until 1048576iterations occur. An alternate and more useful syntax is while (expression) ( statements ), which evaluates statements after every non-zero evaluation of expression.\n\n"
    },
    "LOOP OSCIIBOT": {
        "prefix": "loop",
        "scope": "eel2",
        "body": "loop(${1:count}, ${2:expression})$0",
        "description": "[OSCIIBOT]\n\nEvaluates count once, and then executes expression count, but not more than 1048576, times.\n\n"
    },
    "SIN OSCIIBOT": {
        "prefix": "sin",
        "scope": "eel2",
        "body": "sin(${1:angle})$0",
        "description": "[OSCIIBOT]\n\nReturns the sine of the angle specified (specified in radians -- to convert from degrees to radians, multiply by $pi/180, or 0.017453).\n\n"
    },
    "COS OSCIIBOT": {
        "prefix": "cos",
        "scope": "eel2",
        "body": "cos(${1:angle})$0",
        "description": "[OSCIIBOT]\n\nReturns the cosine of the angle specified (specified in radians).\n\n"
    },
    "TAN OSCIIBOT": {
        "prefix": "tan",
        "scope": "eel2",
        "body": "tan(${1:angle})$0",
        "description": "[OSCIIBOT]\n\nReturns the tangent of the angle specified (specified in radians).\n\n"
    },
    "SQRT OSCIIBOT": {
        "prefix": "sqrt",
        "scope": "eel2",
        "body": "sqrt(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns the square root of the parameter. If the parameter is negative, the return value is undefined.\n\n"
    },
    "LOG OSCIIBOT": {
        "prefix": "log",
        "scope": "eel2",
        "body": "log(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns the natural logarithm (base e) of the parameter. If the value is not greater than 0, the return value is undefined.\n\n"
    },
    "LOG10 OSCIIBOT": {
        "prefix": "log10",
        "scope": "eel2",
        "body": "log10(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns the base-10 logarithm of the parameter. If the value is not greater than 0, the return value is undefined.\n\n"
    },
    "ASIN OSCIIBOT": {
        "prefix": "asin",
        "scope": "eel2",
        "body": "asin(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n"
    },
    "ACOS OSCIIBOT": {
        "prefix": "acos",
        "scope": "eel2",
        "body": "acos(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n"
    },
    "ATAN OSCIIBOT": {
        "prefix": "atan",
        "scope": "eel2",
        "body": "atan(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n"
    },
    "ATAN2 OSCIIBOT": {
        "prefix": "atan2",
        "scope": "eel2",
        "body": "atan2(${1:numerator}, ${2:denominator})$0",
        "description": "[OSCIIBOT]\n\nReturns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.\n\n"
    },
    "EXP OSCIIBOT": {
        "prefix": "exp",
        "scope": "eel2",
        "body": "exp(${1:exponent})$0",
        "description": "[OSCIIBOT]\n\nReturns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.\n\n"
    },
    "ABS OSCIIBOT": {
        "prefix": "abs",
        "scope": "eel2",
        "body": "abs(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns the absolute value of the parameter.\n\n"
    },
    "SQR OSCIIBOT": {
        "prefix": "sqr",
        "scope": "eel2",
        "body": "sqr(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns the square of the parameter (similar to value*value, but only evaluating value once).\n\n"
    },
    "MIN OSCIIBOT": {
        "prefix": "min",
        "scope": "eel2",
        "body": "min(${1:value}, ${2:value})$0",
        "description": "[OSCIIBOT]\n\nReturns (by reference) the minimum value of the two parameters. Since min() returns by reference, expressions such as min(x,y) = 5 are possible.\n\n"
    },
    "MAX OSCIIBOT": {
        "prefix": "max",
        "scope": "eel2",
        "body": "max(${1:value}, ${2:value})$0",
        "description": "[OSCIIBOT]\n\nReturns (by reference) the maximum value of the two parameters. Since max() returns by reference, expressions such as max(x,y) = 5 are possible.\n\n"
    },
    "SIGN OSCIIBOT": {
        "prefix": "sign",
        "scope": "eel2",
        "body": "sign(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns 1.0 if the parameter is greater than 0, -1.0 if the parameter is less than 0, or 0 if the parameter is 0.\n\n"
    },
    "FLOOR OSCIIBOT": {
        "prefix": "floor",
        "scope": "eel2",
        "body": "floor(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).\n\n"
    },
    "CEIL OSCIIBOT": {
        "prefix": "ceil",
        "scope": "eel2",
        "body": "ceil(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).\n\n"
    },
    "INVSQRT OSCIIBOT": {
        "prefix": "invsqrt",
        "scope": "eel2",
        "body": "invsqrt(${1:value})$0",
        "description": "[OSCIIBOT]\n\nReturns a fast inverse square root (1/sqrt(x)) approximation of the parameter.\n\n"
    },
    "FREEMBUF OSCIIBOT": {
        "prefix": "freembuf",
        "scope": "eel2",
        "body": "freembuf(${1:address})$0",
        "description": "[OSCIIBOT]\n\nHints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.\n\n"
    },
    "MEMCPY OSCIIBOT": {
        "prefix": "memcpy",
        "scope": "eel2",
        "body": "memcpy(${1:dest}, ${2:src}, ${3:length})$0",
        "description": "[OSCIIBOT]\n\nCopies length items of memory from src to dest. Regions are permitted to overlap.\n\n"
    },
    "MEMSET OSCIIBOT": {
        "prefix": "memset",
        "scope": "eel2",
        "body": "memset(${1:offset}, ${2:value}, ${3:length})$0",
        "description": "[OSCIIBOT]\n\nSets length items of memory at offset to value.\n\n"
    },
    "MEM_GET_VALUES OSCIIBOT": {
        "prefix": "mem_get_values",
        "scope": "eel2",
        "body": "mem_get_values(${1:offset}, ${2: ...})$0",
        "description": "[OSCIIBOT]\n\nReads values from memory starting at offset into variables specified. Slower than regular memory reads for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n"
    },
    "MEM_SET_VALUES OSCIIBOT": {
        "prefix": "mem_set_values",
        "scope": "eel2",
        "body": "mem_set_values(${1:offset}, ${2: ...})$0",
        "description": "[OSCIIBOT]\n\nWrites values to memory starting at offset from variables specified. Slower than regular memory writes for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n"
    },
    "STACK_PUSH OSCIIBOT": {
        "prefix": "stack_push",
        "scope": "eel2",
        "body": "stack_push(${1:value})$0",
        "description": "[OSCIIBOT]\n\nPushes value onto the user stack, returns a reference to the parameter.\n\n"
    },
    "STACK_POP OSCIIBOT": {
        "prefix": "stack_pop",
        "scope": "eel2",
        "body": "stack_pop(${1:value})$0",
        "description": "[OSCIIBOT]\n\nPops a value from the user stack into value, or into a temporary buffer if value is not specified, and returns a reference to where the stack was popped. Note that no checking is done to determine if the stack is empty, and as such stack_pop() will never fail.\n\n"
    },
    "STACK_PEEK OSCIIBOT": {
        "prefix": "stack_peek",
        "scope": "eel2",
        "body": "stack_peek(${1:index})$0",
        "description": "[OSCIIBOT]\n\nReturns a reference to the item on the top of the stack (if index is 0), or to the Nth item on the stack if index is greater than 0. \n\n"
    },
    "STACK_EXCH OSCIIBOT": {
        "prefix": "stack_exch",
        "scope": "eel2",
        "body": "stack_exch(${1:value})$0",
        "description": "[OSCIIBOT]\n\nExchanges a value with the top of the stack, and returns a reference to the parameter (with the new value).\n\n"
    },
    "RAND OSCIIBOT": {
        "prefix": "rand",
        "scope": "eel2",
        "body": "rand(${1:max})$0",
        "description": "[OSCIIBOT]\n\nReturns a psuedorandom real number between 0 and the parameter, inclusive. If the parameter is omitted or less than 1.0, 1.0 is used as a maximum instead.\n\n"
    },
    "MIDISEND OSCIIBOT": {
        "prefix": "midisend",
        "scope": "eel2",
        "body": "midisend(${1:device_index})$0",
        "description": "[OSCIIBOT]\n\nSends a MIDI event (specified by variables msg1,msg2,msg3) to the device specified by device_index.\n\ndevice_index can be -100 to send to all outputs opened by application, -1 to send to all outputs opened by script. \n\n"
    },
    "MIDISEND_STR OSCIIBOT": {
        "prefix": "midisend_str",
        "scope": "eel2",
        "body": "midisend_str(${1:device_index}, ${2:\"string\"})$0",
        "description": "[OSCIIBOT]\n\n(v0.5+) Sends a MIDI event (specified by the contents of a string) to the device specified by device_index.\n\ndevice_index can be -100 to send to all outputs opened by application, -1 to send to all outputs opened by script. Can be used to send SysEx, for example: midisend_str(midiout, \"\\xF0\\x00\\x01\\x02\\xF7\").\n\n"
    },
    "OSCSEND OSCIIBOT": {
        "prefix": "oscsend",
        "scope": "eel2",
        "body": "oscsend(${1:device_index}, ${2:\"string\"}, ${3:value}, ${4:...})$0",
        "description": "[OSCIIBOT]\n\nSends an OSC event (specified by \"string\" and one or more parameters specifying values) to device specified by device_index. \n\ndevice_index can be -100 to send to all outputs opened by application, -1 to send to all outputs opened by script.\n\n\"string\" is OSC message, and can have a prefix specifying type and count of values. \n\nAdditional parameters (after values) will be used as parameters to any format specifiers in \"string\". \n\nPrefixes are one or more characters of 'f' (float), 'i' (integer), 'b' (bool), 's' (string), which specify an OSC value of that type.\n\n"
    },
    "OSCMATCH OSCIIBOT": {
        "prefix": "oscmatch",
        "scope": "eel2",
        "body": "oscmatch(${1:\"string\"}, ${2:format-output})$0",
        "description": "[OSCIIBOT]\n\n"
    },
    "OSCPARM OSCIIBOT": {
        "prefix": "oscparm",
        "scope": "eel2",
        "body": "oscparm(${1:parm_idx}, ${2:type}, ${3:string})$0",
        "description": "[OSCIIBOT]\n\nGets the parameter value for the current OSC message. \n\nIf type is specified, it will be set to the type of the parameter ('f', 's', etc). \n\nIf #string is specified and type is 's', #string will be set to the OSC parameter string.\n\n"
    },
    "GET_DEVICE_OPEN_TIME OSCIIBOT": {
        "prefix": "get_device_open_time",
        "scope": "eel2",
        "body": "get_device_open_time(${1:device_index})$0",
        "description": "[OSCIIBOT]\n\nReturns the timestamp (similar to time_precise()) of the last time this device was opened/re-opened, can be used to detect device reconnection.\n\n"
    },
    "PRINTF OSCIIBOT": {
        "prefix": "printf",
        "scope": "eel2",
        "body": "printf(${1:\"format\"}, ${2: ...})$0",
        "description": "[OSCIIBOT]\n\nOutput formatted string to system-specific destination, see sprintf() for more information\n\n"
    },
    "SPRINTF OSCIIBOT": {
        "prefix": "sprintf",
        "scope": "eel2",
        "body": "sprintf(${1:dest}, ${2:\"format\"}, ${3: ...})$0",
        "description": "[OSCIIBOT]\n\nFormats a string and stores it in #dest. Format specifiers begin with %, and may include:\n\n%% = %\n\n%s = string from parameter\n\n%d = parameter as integer\n\n%i = parameter as integer\n\n%u = parameter as unsigned integer\n\n%x = parameter as hex (lowercase) integer\n\n%X = parameter as hex (uppercase) integer\n\n%c = parameter as character\n\n%f = parameter as floating point\n\n%e = parameter as floating point (scientific notation, lowercase)\n\n%E = parameter as floating point (scientific notation, uppercase)\n\n%g = parameter as floating point (shortest representation, lowercase)\n\n%G = parameter as floating point (shortest representation, uppercase)\n\nMany standard C printf() modifiers can be used, including:\n\n%.10s = string, but only print up to 10 characters\n\n%-10s = string, left justified to 10 characters\n\n%10s = string, right justified to 10 characters\n\n%+f = floating point, always show sign\n\n%.4f = floating point, minimum of 4 digits after decimal point\n\n%10d = integer, minimum of 10 digits (space padded)\n\n%010f = integer, minimum of 10 digits (zero padded)\n\nValues for format specifiers can be specified as additional parameters to sprintf, or within {} in the format specifier (such as %{varname}d, in that case a global variable is always used).\n\n"
    },
    "MATCHI OSCIIBOT": {
        "prefix": "matchi",
        "scope": "eel2",
        "body": "matchi(${1:\"needle\"}, ${2:\"haystack\"}, ${3: ...})$0",
        "description": "[OSCIIBOT]\n\nCase-insensitive version of match().\n\n"
    },
    "MATCH OSCIIBOT": {
        "prefix": "match",
        "scope": "eel2",
        "body": "match(${1:\"needle\"}, ${2:\"haystack\"}, ${3: ...})$0",
        "description": "[OSCIIBOT]\n\nSearches for the first parameter in the second parameter, using a simplified regular expression syntax.\n\n* = match 0 or more characters\n\n*? = match 0 or more characters, lazy\n\n+ = match 1 or more characters\n\n+? = match 1 or more characters, lazy\n\n? = match one character\n\nYou can also use format specifiers to match certain types of data, and optionally put that into a variable:\n\n%s means 1 or more chars\n\n%0s means 0 or more chars\n\n%5s means exactly 5 chars\n\n%5-s means 5 or more chars\n\n%-10s means 1-10 chars\n\n%3-5s means 3-5 chars\n\n%0-5s means 0-5 chars\n\n%x, %d, %u, and %f are available for use similarly\n\n%c can be used, but can't take any length modifiers\n\nUse uppercase (%S, %D, etc) for lazy matching\n\nSee also sprintf() for other notes, including specifying direct variable references via {}.\n\n"
    },
    "STRLEN OSCIIBOT": {
        "prefix": "strlen",
        "scope": "eel2",
        "body": "strlen(${1:\"str\"})$0",
        "description": "[OSCIIBOT]\n\nReturns the length of the string passed as a parameter\n\n"
    },
    "STRCPY OSCIIBOT": {
        "prefix": "strcpy",
        "scope": "eel2",
        "body": "strcpy(${1:str}, ${2:\"srcstr\"})$0",
        "description": "[OSCIIBOT]\n\nCopies the contents of srcstr to #str, and returns #str\n\n"
    },
    "STRCAT OSCIIBOT": {
        "prefix": "strcat",
        "scope": "eel2",
        "body": "strcat(${1:str}, ${2:\"srcstr\"})$0",
        "description": "[OSCIIBOT]\n\nAppends srcstr to #str, and returns #str\n\n"
    },
    "STRCMP OSCIIBOT": {
        "prefix": "strcmp",
        "scope": "eel2",
        "body": "strcmp(${1:\"str\"}, ${2:\"str2\"})$0",
        "description": "[OSCIIBOT]\n\nCompares strings, returning 0 if equal\n\n"
    },
    "STRICMP OSCIIBOT": {
        "prefix": "stricmp",
        "scope": "eel2",
        "body": "stricmp(${1:\"str\"}, ${2:\"str2\"})$0",
        "description": "[OSCIIBOT]\n\nCompares strings ignoring case, returning 0 if equal\n\n"
    },
    "STRNCMP OSCIIBOT": {
        "prefix": "strncmp",
        "scope": "eel2",
        "body": "strncmp(${1:\"str\"}, ${2:\"str2\"}, ${3:maxlen})$0",
        "description": "[OSCIIBOT]\n\nCompares strings giving up after maxlen characters, returning 0 if equal\n\n"
    },
    "STRNICMP OSCIIBOT": {
        "prefix": "strnicmp",
        "scope": "eel2",
        "body": "strnicmp(${1:\"str\"}, ${2:\"str2\"}, ${3:maxlen})$0",
        "description": "[OSCIIBOT]\n\nCompares strings giving up after maxlen characters, ignoring case, returning 0 if equal\n\n"
    },
    "STRNCPY OSCIIBOT": {
        "prefix": "strncpy",
        "scope": "eel2",
        "body": "strncpy(${1:str}, ${2:\"srcstr\"}, ${3:maxlen})$0",
        "description": "[OSCIIBOT]\n\nCopies srcstr to #str, stopping after maxlen characters. Returns #str.\n\n"
    },
    "STRNCAT OSCIIBOT": {
        "prefix": "strncat",
        "scope": "eel2",
        "body": "strncat(${1:str}, ${2:\"srcstr\"}, ${3:maxlen})$0",
        "description": "[OSCIIBOT]\n\nAppends srcstr to #str, stopping after maxlen characters of srcstr. Returns #str.\n\n"
    },
    "STRCPY_FROM OSCIIBOT": {
        "prefix": "strcpy_from",
        "scope": "eel2",
        "body": "strcpy_from(${1:str}, ${2:\"srcstr\"}, ${3:offset})$0",
        "description": "[OSCIIBOT]\n\nCopies srcstr to #str, but starts reading srcstr at offset offset\n\n"
    },
    "STRCPY_SUBSTR OSCIIBOT": {
        "prefix": "strcpy_substr",
        "scope": "eel2",
        "body": "strcpy_substr(${1:str}, ${2:\"srcstr\"}, ${3:offs}, ${4:ml})$0",
        "description": "[OSCIIBOT]\n\nPHP-style (start at offs, offs<0 means from end, ml for maxlen, ml<0 = reduce length by this amt)\n\n"
    },
    "STR_GETCHAR OSCIIBOT": {
        "prefix": "str_getchar",
        "scope": "eel2",
        "body": "str_getchar(${1:\"str\"}, ${2:offset}, ${3:type})$0",
        "description": "[OSCIIBOT]\n\nReturns the data at byte-offset offset of str. If offset is negative, position is relative to end of string.type defaults to signed char, but can be specified to read raw binary data in other formats (note the single quotes, these are single/multi-byte characters):\n\n'c' - signed char\n\n'cu' - unsigned char\n\n's' - signed short\n\n'S' - signed short, big endian\n\n'su' - unsigned short\n\n'Su' - unsigned short, big endian\n\n'i' - signed int\n\n'I' - signed int, big endian\n\n'iu' - unsigned int\n\n'Iu' - unsigned int, big endian\n\n'f' - float\n\n'F' - float, big endian\n\n'd' - double\n\n'D' - double, big endian\n\n"
    },
    "STR_SETCHAR OSCIIBOT": {
        "prefix": "str_setchar",
        "scope": "eel2",
        "body": "str_setchar(${1:str}, ${2:offset}, ${3:val}, ${4:type})$0",
        "description": "[OSCIIBOT]\n\nSets value at offset offset, type optional. offset may be negative to refer to offset relative to end of string, or between 0 and length, inclusive, and if set to length it will lengthen string. see str_getchar() for more information on types.\n\n"
    },
    "STR_SETLEN OSCIIBOT": {
        "prefix": "str_setlen",
        "scope": "eel2",
        "body": "str_setlen(${1:str}, ${2:len})$0",
        "description": "[OSCIIBOT]\n\nSets length of #str (if increasing, will be space-padded), and returns #str.\n\n"
    },
    "STR_DELSUB OSCIIBOT": {
        "prefix": "str_delsub",
        "scope": "eel2",
        "body": "str_delsub(${1:str}, ${2:pos}, ${3:len})$0",
        "description": "[OSCIIBOT]\n\nDeletes len characters at offset pos from #str, and returns #str.\n\n"
    },
    "STR_INSERT OSCIIBOT": {
        "prefix": "str_insert",
        "scope": "eel2",
        "body": "str_insert(${1:str}, ${2:\"srcstr\"}, ${3:pos})$0",
        "description": "[OSCIIBOT]\n\nInserts srcstr into #str at offset pos. Returns #str\n\n"
    },
    "SLEEP OSCIIBOT": {
        "prefix": "sleep",
        "scope": "eel2",
        "body": "sleep(${1:ms})$0",
        "description": "[OSCIIBOT]\n\nYields the CPU for the millisecond count specified, calling Sleep() on Windows or usleep() on other platforms.\n\n"
    },
    "TIME OSCIIBOT": {
        "prefix": "time",
        "scope": "eel2",
        "body": "time(${1:val})$0",
        "description": "[OSCIIBOT]\n\nSets the parameter (or a temporary buffer if omitted) to the number of seconds since January 1, 1970, and returns a reference to that value. The granularity of the value returned is 1 second.\n\n"
    },
    "TIME_PRECISE OSCIIBOT": {
        "prefix": "time_precise",
        "scope": "eel2",
        "body": "time_precise(${1:val})$0",
        "description": "[OSCIIBOT]\n\nSets the parameter (or a temporary buffer if omitted) to a system-local timestamp in seconds, and returns a reference to that value. The granularity of the value returned is system defined (but generally significantly smaller than one second).\n\n"
    },
    "EVAL OSCIIBOT": {
        "prefix": "eval",
        "scope": "eel2",
        "body": "eval(${1:\"code\"})$0",
        "description": "[OSCIIBOT]\n\nExecutes code passed in. Code can use functions, but functions created in code can't be used elsewhere.\n\n"
    },
    "TCP_LISTEN OSCIIBOT": {
        "prefix": "tcp_listen",
        "scope": "eel2",
        "body": "tcp_listen(${1:port}, ${2:\"interface\"}, ${3:ip_out})$0",
        "description": "[OSCIIBOT]\n\nListens on port specified. Returns less than 0 if could not listen, 0 if no new connection available, or greater than 0 (as a TCP connection ID) if a new connection was made. If a connection made and #ip_out specified, it will be set to the remote IP. interface can be empty for all interfaces, otherwise an interface IP as a string.\n\n"
    },
    "TCP_LISTEN_END OSCIIBOT": {
        "prefix": "tcp_listen_end",
        "scope": "eel2",
        "body": "tcp_listen_end(${1:port})$0",
        "description": "[OSCIIBOT]\n\nEnds listening on port specified.\n\n"
    },
    "TCP_CONNECT OSCIIBOT": {
        "prefix": "tcp_connect",
        "scope": "eel2",
        "body": "tcp_connect(${1:\"address\"}, ${2:port}, ${3:block})$0",
        "description": "[OSCIIBOT]\n\nCreate a new TCP connection to address:port. If block is specified and 0, connection will be made nonblocking. Returns TCP connection ID greater than 0 on success.\n\n"
    },
    "TCP_SEND OSCIIBOT": {
        "prefix": "tcp_send",
        "scope": "eel2",
        "body": "tcp_send(${1:connection}, ${2:\"str\"}, ${3:len})$0",
        "description": "[OSCIIBOT]\n\nSends a string to connection. Returns -1 on error, 0 if connection is non-blocking and would block, otherwise returns length sent. If len is specified and not less than 1, only the first len bytes of the string parameter will be sent.\n\n"
    },
    "TCP_RECV OSCIIBOT": {
        "prefix": "tcp_recv",
        "scope": "eel2",
        "body": "tcp_recv(${1:connection}, ${2:str}, ${3:maxlen})$0",
        "description": "[OSCIIBOT]\n\nReceives data from a connection to #str. If maxlen is specified, no more than maxlen bytes will be received. If non-blocking, 0 will be returned if would block. Returns less than 0 if error.\n\n"
    },
    "TCP_SET_BLOCK OSCIIBOT": {
        "prefix": "tcp_set_block",
        "scope": "eel2",
        "body": "tcp_set_block(${1:connection}, ${2:block})$0",
        "description": "[OSCIIBOT]\n\nSets whether a connection blocks.\n\n"
    },
    "TCP_CLOSE OSCIIBOT": {
        "prefix": "tcp_close",
        "scope": "eel2",
        "body": "tcp_close(${1:connection})$0",
        "description": "[OSCIIBOT]\n\nCloses a TCP connection created by tcp_listen() or tcp_connect().\n\n"
    },
    "FOPEN OSCIIBOT": {
        "prefix": "fopen",
        "scope": "eel2",
        "body": "fopen(${1:\"fn\"}, ${2:\"mode\"})$0",
        "description": "[OSCIIBOT]\n\nOpens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.\n\n"
    },
    "FCLOSE OSCIIBOT": {
        "prefix": "fclose",
        "scope": "eel2",
        "body": "fclose(${1:fp})$0",
        "description": "[OSCIIBOT]\n\nCloses a file previously opened with fopen().\n\n"
    },
    "FREAD OSCIIBOT": {
        "prefix": "fread",
        "scope": "eel2",
        "body": "fread(${1:fp}, ${2:str}, ${3:length})$0",
        "description": "[OSCIIBOT]\n\nReads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.\n\n"
    },
    "FGETS OSCIIBOT": {
        "prefix": "fgets",
        "scope": "eel2",
        "body": "fgets(${1:fp}, ${2:str})$0",
        "description": "[OSCIIBOT]\n\nReads a line from file fp into #str. Returns length of #str read.\n\n"
    },
    "FGETC OSCIIBOT": {
        "prefix": "fgetc",
        "scope": "eel2",
        "body": "fgetc(${1:fp})$0",
        "description": "[OSCIIBOT]\n\nReads a character from file fp, returns -1 if EOF.\n\n"
    },
    "FWRITE OSCIIBOT": {
        "prefix": "fwrite",
        "scope": "eel2",
        "body": "fwrite(${1:fp}, ${2:str}, ${3:len})$0",
        "description": "[OSCIIBOT]\n\nWrites up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.\n\n"
    },
    "FPRINTF OSCIIBOT": {
        "prefix": "fprintf",
        "scope": "eel2",
        "body": "fprintf(${1:fp}, ${2:\"format\"}, ${3:...})$0",
        "description": "[OSCIIBOT]\n\nFormats a string and writes it to file fp. For more information on format specifiers, see sprintf(). Returns bytes written to file.\n\n"
    },
    "FSEEK OSCIIBOT": {
        "prefix": "fseek",
        "scope": "eel2",
        "body": "fseek(${1:fp}, ${2:offset}, ${3:whence})$0",
        "description": "[OSCIIBOT]\n\nSeeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.\n\n"
    },
    "FTELL OSCIIBOT": {
        "prefix": "ftell",
        "scope": "eel2",
        "body": "ftell(${1:fp})$0",
        "description": "[OSCIIBOT]\n\nRetunrs the current file position.\n\n"
    },
    "FEOF OSCIIBOT": {
        "prefix": "feof",
        "scope": "eel2",
        "body": "feof(${1:fp})$0",
        "description": "[OSCIIBOT]\n\nReturns nonzero if the file fp is at the end of file.\n\n"
    },
    "FFLUSH OSCIIBOT": {
        "prefix": "fflush",
        "scope": "eel2",
        "body": "fflush(${1:fp})$0",
        "description": "[OSCIIBOT]\n\nIf file fp is open for writing, flushes out any buffered data to disk.\n\n"
    },
    "GFX_INIT OSCIIBOT": {
        "prefix": "gfx_init",
        "scope": "eel2",
        "body": "gfx_init(${1:\"name\"}, ${2:width}, ${3:height}, ${4:xpos}, ${5:ypos})$0",
        "description": "[OSCIIBOT]\n\nInitializes the graphics window with title name. Suggested width and height can be specified.\n\nOnce the graphics window is open, gfx_update() should be called periodically. \n\n"
    },
    "GFX_QUIT OSCIIBOT": {
        "prefix": "gfx_quit",
        "scope": "eel2",
        "body": "gfx_quit()$0",
        "description": "[OSCIIBOT]\n\nCloses the graphics window.\n\n"
    },
    "GFX_AAAAA OSCIIBOT": {
        "prefix": "gfx_aaaaa",
        "scope": "eel2",
        "body": "gfx_aaaaa()$0",
        "description": "[OSCIIBOT]\n\nThe following global variables are special and will be used by the graphics system:\n\ngfx_r, gfx_g, gfx_b, gfx_a - These represent the current red, green, blue, and alpha components used by drawing operations (0.0..1.0). \n\ngfx_w, gfx_h - These are set to the current width and height of the UI framebuffer. \n\ngfx_x, gfx_y - These set the \"current\" graphics position in x,y. You can set these yourselves, and many of the drawing functions update them as well. \n\ngfx_mode - Set to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx_a to negative and use gfx_mode as additive). Add 2.0 to disable source alpha for gfx_blit(). Add 4.0 to disable filtering for gfx_blit(). \n\ngfx_clear - If set to a value greater than -1.0, this will result in the framebuffer being cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black). \n\ngfx_dest - Defaults to -1, set to 0..127 to have drawing operations go to an offscreen buffer (or loaded image).\n\ngfx_texth - Set to the height of a line of text in the current font. Do not modify this variable.\n\ngfx_ext_retina - If set to 1.0 on initialization, will be updated to 2.0 if high resolution display is supported, and if so gfx_w/gfx_h/etc will be doubled.\n\nmouse_x, mouse_y - mouse_x and mouse_y are set to the coordinates of the mouse relative to the graphics window.\n\nmouse_wheel, mouse_hwheel - mouse wheel (and horizontal wheel) positions. These will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n\nmouse_cap is a bitfield of mouse and keyboard modifier state.\n\n1: left mouse button\n\n2: right mouse button\n\n4: Control key\n\n8: Shift key\n\n16: Alt key\n\n32: Windows key\n\n64: middle mouse button\n\n"
    },
    "GFX_GETCHAR OSCIIBOT": {
        "prefix": "gfx_getchar",
        "scope": "eel2",
        "body": "gfx_getchar(${1:char})$0",
        "description": "[OSCIIBOT]\n\nIf char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed.\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\nModified and special keys can also be returned, including:\n\nCtrl/Cmd+A..Ctrl+Z as 1..26\n\nCtrl/Cmd+Alt+A..Z as 257..282\n\nAlt+A..Z as 'A'+256..'Z'+256\n\n27 for ESC\n\n13 for Enter\n\n' ' for space\n\n"
    },
    "GFX_SHOWMENU OSCIIBOT": {
        "prefix": "gfx_showmenu",
        "scope": "eel2",
        "body": "gfx_showmenu(${1:\"str\"})$0",
        "description": "[OSCIIBOT]\n\nShows a popup menu at gfx_x,gfx_y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\nAn empty field will appear as a separator in the menu. gfx_showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\ngfx_showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n"
    },
    "GFX_SETCURSOR OSCIIBOT": {
        "prefix": "gfx_setcursor",
        "scope": "eel2",
        "body": "gfx_setcursor(${1:resource_id})$0",
        "description": "[OSCIIBOT]\n\nSets the mouse cursor. resource_id is a value like 32512 (for an arrow cursor).\n\n"
    },
    "GFX_LINETO OSCIIBOT": {
        "prefix": "gfx_lineto",
        "scope": "eel2",
        "body": "gfx_lineto(${1:x}, ${2:y}, ${3:aa})$0",
        "description": "[OSCIIBOT]\n\nDraws a line from gfx_x,gfx_y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx_x and gfx_y to x,y.\n\n"
    },
    "GFX_LINE OSCIIBOT": {
        "prefix": "gfx_line",
        "scope": "eel2",
        "body": "gfx_line(${1:x}, ${2:y}, ${3:x2}, ${4:y2}, ${5:aa})$0",
        "description": "[OSCIIBOT]\n\nDraws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n"
    },
    "GFX_RECTTO OSCIIBOT": {
        "prefix": "gfx_rectto",
        "scope": "eel2",
        "body": "gfx_rectto(${1:x}, ${2:y})$0",
        "description": "[OSCIIBOT]\n\nFills a rectangle from gfx_x,gfx_y to x,y. Updates gfx_x,gfx_y to x,y. \n\n"
    },
    "GFX_RECT OSCIIBOT": {
        "prefix": "gfx_rect",
        "scope": "eel2",
        "body": "gfx_rect(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:filled})$0",
        "description": "[OSCIIBOT]\n\nFills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n"
    },
    "GFX_SETPIXEL OSCIIBOT": {
        "prefix": "gfx_setpixel",
        "scope": "eel2",
        "body": "gfx_setpixel(${1:r}, ${2:g}, ${3:b})$0",
        "description": "[OSCIIBOT]\n\nWrites a pixel of r,g,b to gfx_x,gfx_y.\n\n"
    },
    "GFX_GETPIXEL OSCIIBOT": {
        "prefix": "gfx_getpixel",
        "scope": "eel2",
        "body": "gfx_getpixel(${1:r}, ${2:g}, ${3:b})$0",
        "description": "[OSCIIBOT]\n\nGets the value of the pixel at gfx_x,gfx_y into r,g,b. \n\n"
    },
    "GFX_DRAWNUMBER OSCIIBOT": {
        "prefix": "gfx_drawnumber",
        "scope": "eel2",
        "body": "gfx_drawnumber(${1:n}, ${2:ndigits})$0",
        "description": "[OSCIIBOT]\n\nDraws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.\n\n"
    },
    "GFX_DRAWCHAR OSCIIBOT": {
        "prefix": "gfx_drawchar",
        "scope": "eel2",
        "body": "gfx_drawchar(${1:char})$0",
        "description": "[OSCIIBOT]\n\nDraws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.\n\n"
    },
    "GFX_DRAWSTR OSCIIBOT": {
        "prefix": "gfx_drawstr",
        "scope": "eel2",
        "body": "gfx_drawstr(${1:\"str\"}, ${2:flags}, ${3:right}, ${4:bottom})$0",
        "description": "[OSCIIBOT]\n\nDraws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.\n\nIf flags, right ,bottom passed in:\n\nflags&1: center horizontally\n\nflags&2: right justify\n\nflags&4: center vertically\n\nflags&8: bottom justify\n\nflags&256: ignore right/bottom, otherwise text is clipped to (gfx_x, gfx_y, right, bottom)\n\n"
    },
    "GFX_MEASURESTR OSCIIBOT": {
        "prefix": "gfx_measurestr",
        "scope": "eel2",
        "body": "gfx_measurestr(${1:\"str\"}, ${2:w}, ${3:h})$0",
        "description": "[OSCIIBOT]\n\nMeasures the drawing dimensions of a string with the current font (as set by gfx_setfont). \n\n"
    },
    "GFX_MEASURECHAR OSCIIBOT": {
        "prefix": "gfx_measurechar",
        "scope": "eel2",
        "body": "gfx_measurechar(${1:character}, ${2:w}, ${3:h})$0",
        "description": "[OSCIIBOT]\n\nMeasures the drawing dimensions of a character with the current font (as set by gfx_setfont). \n\n"
    },
    "GFX_SETFONT OSCIIBOT": {
        "prefix": "gfx_setfont",
        "scope": "eel2",
        "body": "gfx_setfont(${1:idx}, ${2:\"fontface\"}, ${3: sz}, ${4: flags})$0",
        "description": "[OSCIIBOT]\n\nCan select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx_setfont(), gfx_texth may be updated to reflect the new average line height.\n\n"
    },
    "GFX_GETFONT OSCIIBOT": {
        "prefix": "gfx_getfont",
        "scope": "eel2",
        "body": "gfx_getfont(${1:str})$0",
        "description": "[OSCIIBOT]\n\nReturns current font index. If a string is passed, it will receive the actual font face used by this font, if available.\n\n"
    },
    "GFX_PRINTF OSCIIBOT": {
        "prefix": "gfx_printf",
        "scope": "eel2",
        "body": "gfx_printf(${1:\"format\"}, ${2: ...})$0",
        "description": "[OSCIIBOT]\n\nFormats and draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n"
    },
    "GFX_BLURTO OSCIIBOT": {
        "prefix": "gfx_blurto",
        "scope": "eel2",
        "body": "gfx_blurto(${1:x}, ${2:y})$0",
        "description": "[OSCIIBOT]\n\nBlurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.\n\n"
    },
    "GFX_BLIT OSCIIBOT": {
        "prefix": "gfx_blit",
        "scope": "eel2",
        "body": "gfx_blit(${1:source}, ${2: scale}, ${3: rotation}, ${4: srcx}, ${5: srcy}, ${6: srcw}, ${7: srch}, ${8: destx}, ${9: desty}, ${10: destw}, ${11: desth}, ${12: rotxoffs}, ${13: rotyoffs})$0",
        "description": "[OSCIIBOT]\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size), destx/desty/destw/desth specify dest rectangle (if not specified, these will default to reasonable defaults -- destw/desth default to srcw/srch * scale). \n\n"
    },
    "GFX_BLITEXT OSCIIBOT": {
        "prefix": "gfx_blitext",
        "scope": "eel2",
        "body": "gfx_blitext(${1:source}, ${2:coordinatelist}, ${3:rotation})$0",
        "description": "[OSCIIBOT]\n\nDeprecated, use gfx_blit instead.\n\n"
    },
    "GFX_GETIMGDIM OSCIIBOT": {
        "prefix": "gfx_getimgdim",
        "scope": "eel2",
        "body": "gfx_getimgdim(${1:image}, ${2:w}, ${3:h})$0",
        "description": "[OSCIIBOT]\n\nRetreives the dimensions of image (representing a filename: index number) into w and h. Sets these values to 0 if an image failed loading (or if the filename index is invalid).\n\n"
    },
    "GFX_SETIMGDIM OSCIIBOT": {
        "prefix": "gfx_setimgdim",
        "scope": "eel2",
        "body": "gfx_setimgdim(${1:image}, ${2:w}, ${3:h})$0",
        "description": "[OSCIIBOT]\n\nResize image referenced by index 0..127, width and height must be 0-2048. The contents of the image will be undefined after the resize.\n\n"
    },
    "GFX_LOADIMG OSCIIBOT": {
        "prefix": "gfx_loadimg",
        "scope": "eel2",
        "body": "gfx_loadimg(${1:image}, ${2:\"filename\"})$0",
        "description": "[OSCIIBOT]\n\nLoad image from filename into slot 0..127 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n"
    },
    "GFX_GRADRECT OSCIIBOT": {
        "prefix": "gfx_gradrect",
        "scope": "eel2",
        "body": "gfx_gradrect(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5: r}, ${6:g}, ${7:b}, ${8:a}, ${9: drdx}, ${10: dgdx}, ${11: dbdx}, ${12: dadx}, ${13: drdy}, ${14: dgdy}, ${15: dbdy}, ${16: dady})$0",
        "description": "[OSCIIBOT]\n\nFills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n"
    },
    "GFX_MULADDRECT OSCIIBOT": {
        "prefix": "gfx_muladdrect",
        "scope": "eel2",
        "body": "gfx_muladdrect(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:mul_r}, ${6:mul_g}, ${7:mul_b}, ${8:mul_a}, ${9:add_r}, ${10:add_g}, ${11:add_b}, ${12:add_a})$0",
        "description": "[OSCIIBOT]\n\nMultiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n"
    },
    "GFX_DELTABLIT OSCIIBOT": {
        "prefix": "gfx_deltablit",
        "scope": "eel2",
        "body": "gfx_deltablit(${1:srcimg}, ${2:srcx}, ${3:srcy}, ${4:srcw}, ${5:srch}, ${6:destx}, ${7:desty}, ${8:destw}, ${9:desth}, ${10:dsdx}, ${11:dtdx}, ${12:dsdy}, ${13:dtdy}, ${14:dsdxdy}, ${15:dtdxdy})$0",
        "description": "[OSCIIBOT]\n\nBlits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. \n\n"
    },
    "GFX_TRANSFORMBLIT OSCIIBOT": {
        "prefix": "gfx_transformblit",
        "scope": "eel2",
        "body": "gfx_transformblit(${1:srcimg}, ${2:destx}, ${3:desty}, ${4:destw}, ${5:desth}, ${6:div_w}, ${7:div_h}, ${8:table})$0",
        "description": "[OSCIIBOT]\n\nBlits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (this table must not cross a 65536 item boundary). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n"
    },
    "GFX_CIRCLE OSCIIBOT": {
        "prefix": "gfx_circle",
        "scope": "eel2",
        "body": "gfx_circle(${1:x}, ${2:y}, ${3:r}, ${4:fill}, ${5:antialias})$0",
        "description": "[OSCIIBOT]\n\nDraws a circle, optionally filling/antialiasing. \n\n"
    },
    "GFX_TRIANGLE OSCIIBOT": {
        "prefix": "gfx_triangle",
        "scope": "eel2",
        "body": "gfx_triangle(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${6:y3}, ${7:x4}, ${8:y4...})$0",
        "description": "[OSCIIBOT]\n\nDraws a filled triangle, or any convex polygon. \n\n"
    },
    "GFX_ROUNDRECT OSCIIBOT": {
        "prefix": "gfx_roundrect",
        "scope": "eel2",
        "body": "gfx_roundrect(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:radius}, ${6:antialias})$0",
        "description": "[OSCIIBOT]\n\nDraws a rectangle with rounded corners. \n\n"
    },
    "GFX_ARC OSCIIBOT": {
        "prefix": "gfx_arc",
        "scope": "eel2",
        "body": "gfx_arc(${1:x}, ${2:y}, ${3:r}, ${4:ang1}, ${5:ang2}, ${6:antialias})$0",
        "description": "[OSCIIBOT]\n\nDraws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n"
    },
    "GFX_SET OSCIIBOT": {
        "prefix": "gfx_set",
        "scope": "eel2",
        "body": "gfx_set(${1:r}, ${2:g}, ${3:b}, ${4:a}, ${5:mode}, ${6:dest})$0",
        "description": "[OSCIIBOT]\n\nSets gfx_r/gfx_g/gfx_b/gfx_a/gfx_mode, sets gfx_dest if final parameter specified\n\n"
    },
    "GFX_CLIENTTOSCREEN OSCIIBOT": {
        "prefix": "gfx_clienttoscreen",
        "scope": "eel2",
        "body": "gfx_clienttoscreen(${1:x}, ${2:y})$0",
        "description": "[OSCIIBOT]\n\nConverts client coordinates x,y to screen coordinates.\n\n"
    },
    "GFX_SCREENTOCLIENT OSCIIBOT": {
        "prefix": "gfx_screentoclient",
        "scope": "eel2",
        "body": "gfx_screentoclient(${1:x}, ${2:y})$0",
        "description": "[OSCIIBOT]\n\nConverts screen coordinates x,y to client coordinates.\n\n"
    }
}